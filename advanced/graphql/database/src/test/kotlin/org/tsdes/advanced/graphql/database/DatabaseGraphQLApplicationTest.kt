package org.tsdes.advanced.graphql.database

import io.restassured.RestAssured
import io.restassured.RestAssured.given
import io.restassured.http.ContentType
import org.hamcrest.CoreMatchers
import org.hamcrest.Matchers
import org.hamcrest.Matchers.*
import org.junit.Assert.*
import org.junit.Before
import org.junit.Test
import org.junit.runner.RunWith
import org.springframework.boot.test.context.SpringBootTest
import org.springframework.boot.web.server.LocalServerPort
import org.springframework.test.context.junit4.SpringRunner
import org.springframework.web.client.RestTemplate
import org.springframework.web.util.UriComponentsBuilder
import org.tsdes.advanced.graphql.database.dto.GraphQLResponseDto


@RunWith(SpringRunner::class)
@SpringBootTest(classes = [DatabaseGraphQLApplication::class],
        webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)
class DatabaseGraphQLApplicationTest{


    @LocalServerPort
    protected var port = 0

    private val client: RestTemplate = RestTemplate()

    protected lateinit var uriBuilder: UriComponentsBuilder

    @Before
    fun clean() {

        // RestAssured configs shared by all the tests
        RestAssured.baseURI = "http://localhost"
        RestAssured.port = port
        RestAssured.basePath = "/graphql"
        RestAssured.enableLoggingOfRequestAndResponseIfValidationFails()

        uriBuilder = UriComponentsBuilder.newInstance()
                .scheme("http").host("localhost").port(port).path("/graphql")
    }

    //-------------------------------------------------------------------------------
    //-- these test are the similar to the tests in Resolver module, but with
    //-- no checks on IDs (as those are generated by Hibernate)

    @Test
    fun testBaseGet() {

        given().accept(ContentType.JSON)
                .queryParam("query", "{allPosts{id}}")
                .get()
                .then()
                .statusCode(200)
                .body("$", hasKey("data"))
                .body("$", not(hasKey("errors")))
                .body("data.allPosts.size()", equalTo(3))
    }

    @Test
    fun testGetWithAuthors() {

        given().accept(ContentType.JSON)
                .queryParam("query", "{allPosts{id,author{name}}}")
                .get()
                .then()
                .statusCode(200)
                .body("$", hasKey("data"))
                .body("$", not(hasKey("errors")))
                .body("data.allPosts.size()", equalTo(3))
                .body("data.allPosts.author.name", hasItems("Foo", "John"))
    }

    @Test
    fun testNestingCyclePostToCommentsToParentPost() {

        RestAssured.given().accept(ContentType.JSON)
                .queryParam("query", "{allPosts{id,author{name},text,comments{id,text,author{name},parentPost{id,text}}}}\n")
                .get()
                .then()
                .statusCode(200)
                .body("$", hasKey("data"))
                .body("$", not(Matchers.hasKey("errors")))
                .body("data.allPosts.size()", equalTo(3))
    }



    //-------------------------------------------------------------------------------
    //-- here, we extract the DTOs

    @Test
    fun testBaseGetDto() {

        val uri = uriBuilder.queryParam("query","{allPosts{id}}")
                .build().encode().toUri()

        val response = client.getForEntity(uri, GraphQLResponseDto::class.java)
        assertEquals(200, response.statusCode.value())

        val dto = response.body

        assertNotNull(dto.data)
        assertNull(dto.errors)
        assertEquals(3, dto.data!!.allPosts!!.size)
    }


    @Test
    fun testGetWithAuthorsDto() {

        val uri = uriBuilder.queryParam("query","{allPosts{id,author{name}}}")
                .build().encode().toUri()

        val response = client.getForEntity(uri, GraphQLResponseDto::class.java)
        assertEquals(200, response.statusCode.value())

        val dto = response.body

        assertNotNull(dto.data)
        assertNull(dto.errors)
        assertEquals(3, dto.data!!.allPosts!!.size)

        val names = dto.data!!.allPosts!!
                .map { it.author!!.name!! }
                .distinct()

        assertEquals(2, names.size)
        assertTrue(names.contains("Foo"))
        assertTrue(names.contains("John"))
    }


    @Test
    fun testErrorDto(){

        val wrongField = "blablabla"

        val uri = uriBuilder.queryParam("query","{allPosts{$wrongField}")
                .build().encode().toUri()

        val response = client.getForEntity(uri, GraphQLResponseDto::class.java)
        assertEquals(200, response.statusCode.value())

        val dto = response.body

        assertNull(dto.data)
        assertNotNull(dto.errors)
        assertEquals(1, dto.errors!!.size)

        val msg = dto.errors!!.first().message!!

        assertNotNull(msg)
    }

}